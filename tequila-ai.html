<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Realtime (Browser-only, Debug Logging)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
      body { margin: 24px; display: grid; gap: 14px; max-width: 920px; }
      .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
      input[type=text], input[type=password], select { padding: 10px 12px; font-size: 16px; border: 1px solid #ccc; border-radius: 8px; flex: 1; }
      button { padding: 10px 14px; font-size: 16px; border-radius: 8px; border: 1px solid #ccc; background: #f6f6f6; cursor: pointer; }
      button:disabled { opacity: .5; cursor: not-allowed; }
      #log { white-space: pre-wrap; background: #0c0f12; color: #c9f0ff; padding: 12px; border-radius: 10px; height: 180px; overflow: auto; font-family: ui-monospace, Menlo, Consolas, monospace; }
      .tag { font-size: 12px; padding: 2px 6px; border-radius: 999px; background: #eef; color: #223; }
      .panel { border:1px solid #e6e6e6; border-radius:12px; overflow:hidden; }
      .panel h3 { margin:0; padding:10px 12px; background:#f7f7f7; border-bottom:1px solid #e6e6e6; }
      .exchanges { display:grid; }
      .ex { display:grid; grid-template-columns: 1fr 220px; gap:12px; padding:12px; border-top:1px solid #f0f0f0; }
      .ex:first-child { border-top: none; }
      .msg { line-height:1.35; }
      .role { font-weight:600; margin-right:6px; }
      .tok { font: 12px/1.2 ui-monospace, Menlo, Consolas, monospace; color:#444; }
      .totals { display:flex; gap:12px; padding:10px 12px; background:#fafafa; border-top:1px solid #e6e6e6; }
      .totals div { font: 13px ui-monospace, Menlo, Consolas, monospace; }
      .muted { color:#777; }
    </style>
  </head>
  <body>
    <h1>Realtime Voice — Browser Only</h1>

    <div class="row">
      <input id="apiKey" type="password" placeholder="OPENAI_API_KEY (stored locally)" />
      <input id="model" type="text" value="gpt-realtime" />
      <select id="voice">
        <option value="alloy">alloy</option>
        <option value="verse">verse</option>
        <option value="coral">coral</option>
        <option value="sage">sage</option>
      </select>
      <button id="saveKey">Save</button>
    </div>

    <div class="row">
      <button id="connect">Connect</button>
      <button id="mute" disabled>Mute Mic</button>
      <button id="hangup" disabled>Hang Up</button>
      <span class="tag" id="status">idle</span>
    </div>

    <div class="row">
      <input id="text" type="text" placeholder="Type and Send, or just speak…" />
      <button id="send" disabled>Send</button>
    </div>

    <div class="panel">
      <h3>Exchanges</h3>
      <div id="exchanges" class="exchanges"></div>
      <div class="totals">
        <div id="totIn">In: 0</div>
        <div id="totOut">Out: 0</div>
        <div id="totAll">Total: 0</div>
        <div id="rate" class="muted"></div>
      </div>
    </div>

    <h3>Debug</h3>
    <div id="log"></div>

    <script>
      const $ = (id) => document.getElementById(id);
      const elKey = $("apiKey");
      const elModel = $("model");
      const elVoice = $("voice");
      const btnSave = $("saveKey");
      const btnConn = $("connect");
      const btnMute = $("mute");
      const btnHang = $("hangup");
      const btnSend = $("send");
      const input = $("text");
      const logEl = $("log");
      const statusEl = $("status");
      const exWrap = $("exchanges");
      const totInEl = $("totIn");
      const totOutEl = $("totOut");
      const totAllEl = $("totAll");
      const rateEl = $("rate");

      const store = {
        get k() { return localStorage.getItem("OPENAI_API_KEY") || ""; },
        set k(v) { localStorage.setItem("OPENAI_API_KEY", v); },
        get m() { return localStorage.getItem("REALTIME_MODEL") || "gpt-realtime"; },
        set m(v) { localStorage.setItem("REALTIME_MODEL", v); },
        get v() { return localStorage.getItem("REALTIME_VOICE") || "alloy"; },
        set v(voice) { localStorage.setItem("REALTIME_VOICE", voice); }
      };
      elKey.value = store.k;
      elModel.value = store.m;
      elVoice.value = store.v;

      btnSave.onclick = () => {
        store.k = elKey.value.trim();
        store.m = elModel.value.trim() || "gpt-realtime";
        store.v = elVoice.value;
        toast("Saved.");
      };

      function log(s) { logEl.textContent += s + "\n"; logEl.scrollTop = logEl.scrollHeight; }
      function toast(s) { statusEl.textContent = s; }
      function setControls(state) {
        const connected = state === "connected";
        btnConn.disabled = connected;
        btnMute.disabled = !connected;
        btnHang.disabled = !connected;
        btnSend.disabled = !connected;
        input.disabled = !connected;
      }
      function escapeHtml(s) { return String(s).replace(/[&<>"']/g, c => ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c])); }

      let pc = null, dataChannel = null, localStream = null, remoteAudio = null, micMuted = false;

      const textBuf = Object.create(null);
      let totalIn = 0, totalOut = 0;

      function addAssistantExchange(assistantText, inTok, outTok) {
        const row = document.createElement("div");
        row.className = "ex";
        const msg = document.createElement("div");
        msg.className = "msg";
        msg.innerHTML = `<div><span class="role">${store.v}:</span> ${escapeHtml(assistantText || "")}</div>`;
        const tok = document.createElement("div");
        tok.className = "tok";
        const inS = inTok || 0, outS = outTok || 0;
        tok.textContent = `in: ${inS} | out: ${outS} | turn: ${inS + outS}`;
        row.appendChild(msg);
        row.appendChild(tok);
        exWrap.appendChild(row);
        exWrap.scrollTop = exWrap.scrollHeight;
        totalIn += inS; totalOut += outS;
        totInEl.textContent = "In: " + totalIn;
        totOutEl.textContent = "Out: " + totalOut;
        totAllEl.textContent = "Total: " + (totalIn + totalOut);
      }

      async function connect() {
        const API_KEY = (elKey.value || "").trim();
        const MODEL = (elModel.value || "gpt-realtime").trim();
        const VOICE = elVoice.value;
        if (!API_KEY) { toast("Missing API key"); return; }

        setControls(false);
        toast("connecting…");

        try { localStream = await navigator.mediaDevices.getUserMedia({ audio: true }); }
        catch (e) { log("[err] mic permission failed: " + e); toast("mic blocked"); return; }

        pc = new RTCPeerConnection({ iceServers: [{ urls: ["stun:stun.l.google.com:19302"] }] });

        for (const t of localStream.getTracks()) pc.addTrack(t, localStream);

        remoteAudio = new Audio(); remoteAudio.autoplay = true;
        pc.ontrack = (e) => { const [stream] = e.streams; remoteAudio.srcObject = stream; };

        dataChannel = pc.createDataChannel("oai-events");
        dataChannel.onopen = () => { log("[dc] open"); };
        dataChannel.onclose = () => { log("[dc] close"); };
        dataChannel.onerror = (e) => { log("[dc] error " + (e?.message || e)); };

        dataChannel.onmessage = (e) => {
          let msg;
          try { msg = JSON.parse(e.data); } catch { return; }
          const t = msg.type;

          if (t === "response.output_text.delta" || t === "response.text.delta") {
            const id = msg.response_id || msg.response?.id || "r";
            const d = msg.delta || "";
            textBuf[id] = (textBuf[id] || "") + d;
            return;
          }

          if (t === "response.content_part.done" && msg.part?.type === "text") {
            const id = msg.response_id || "r";
            const s = msg.part.text || "";
            textBuf[id] = (textBuf[id] || "") + s;
            return;
          }

          /* FIX: assistant audio transcripts belong to assistant */
          if (t === "response.content_part.done" && msg.part?.type === "audio" && msg.part?.transcript) {
            const id = msg.response_id || "r";
            const s = msg.part.transcript || "";
            textBuf[id] = (textBuf[id] || "") + s;
            return;
          }

          if (t === "response.output_item.done" && msg.item?.type === "message" && msg.item?.role === "assistant") {
            const id = msg.response_id || "r";
            const texts = (msg.item.content || []).filter(x => x.type === "text").map(x => x.text || "");
            if (texts.length) textBuf[id] = (textBuf[id] || "") + texts.join(" ");
            return;
          }

          if (t === "conversation.item.created" && msg.item?.type === "message" && msg.item?.role === "assistant") {
            const id = msg.response_id || "r";
            const texts = (msg.item.content || []).filter(x => x.type === "text").map(x => x.text || "");
            if (texts.length) textBuf[id] = (textBuf[id] || "") + texts.join(" ");
            return;
          }

          if (
            t === "input_audio_transcription.completed" ||
            t === "response.input_audio_transcription.completed" ||
            t === "conversation.item.input_audio_transcription.completed"
          ) {
            const transcript = msg.transcript || msg.text || msg.result?.text || "";
            if (transcript) log("[you] " + transcript);
            return;
          }

          if (t === "rate_limits.updated") {
            const lim = msg.rate_limits?.find?.(x => x.name === "tokens");
            if (lim) rateEl.textContent = `Rate remaining: ${lim.remaining}/${lim.limit}`;
            return;
          }

          if (t === "response.done" && msg.response) {
            const id = msg.response.id || msg.response_id || "r";
            const assistantText = (textBuf[id] || "").trim();
            delete textBuf[id];

            const usage = msg.response.usage || msg.usage || {};
            const inTok = usage.input_tokens ?? usage.input_token_details?.text_tokens ?? 0;
            const outTok = usage.output_tokens ?? usage.output_token_details?.text_tokens ?? 0;

            if (assistantText) log("[assistant] " + assistantText);
            addAssistantExchange(assistantText, inTok, outTok);
            return;
          }
        };

        const offer = await pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: false });
        await pc.setLocalDescription(offer);

        const createSession = await fetch("https://api.openai.com/v1/realtime/sessions", {
          method: "POST",
          headers: {
            Authorization: "Bearer " + API_KEY,
            "Content-Type": "application/json",
            "OpenAI-Beta": "realtime=v1"
          },
          body: JSON.stringify({
            model: MODEL,
            voice: VOICE,
            output_audio_format: "pcm16",
            instructions: "You are a concise, friendly voice assistant. Keep replies short."
          })
        });
        if (!createSession.ok) { log("[err] session: " + (await createSession.text())); toast("session failed"); return; }
        const { client_secret } = await createSession.json();
        const token = client_secret?.value || client_secret;

        const sdpRes = await fetch("https://api.openai.com/v1/realtime?model=" + encodeURIComponent(MODEL), {
          method: "POST",
          headers: { Authorization: "Bearer " + token, "Content-Type": "application/sdp", "OpenAI-Beta": "realtime=v1" },
          body: offer.sdp
        });
        if (!sdpRes.ok) { log("[err] sdp: " + (await sdpRes.text())); toast("SDP failed"); return; }
        const answerSdp = await sdpRes.text();
        await pc.setRemoteDescription({ type: "answer", sdp: answerSdp });

        setControls("connected");
        toast("connected");
        log("[sys] connected via WebRTC");
      }

      function sendText(text) {
        if (!dataChannel || dataChannel.readyState !== "open") return;
        const createItem = {
          type: "conversation.item.create",
          item: { type: "message", role: "user", content: [{ type: "input_text", text }] }
        };
        const respond = {
          type: "response.create",
          response: { modalities: ["audio", "text"] }
        };
        dataChannel.send(JSON.stringify(createItem));
        dataChannel.send(JSON.stringify(respond));
        log("[you] " + text);
      }

      function toggleMute() {
        if (!localStream) return;
        micMuted = !micMuted;
        localStream.getAudioTracks().forEach((t) => (t.enabled = !micMuted));
        btnMute.textContent = micMuted ? "Unmute Mic" : "Mute Mic";
      }

      function hangup() {
        try { dataChannel?.close(); } catch {}
        try { pc?.getSenders().forEach((s) => s.track && s.track.stop()); } catch {}
        try { pc?.close(); } catch {}
        pc = null; dataChannel = null; localStream = null; remoteAudio = null;
        setControls("idle");
        toast("idle");
        log("[sys] disconnected");
      }

      $("connect").onclick = connect;
      $("mute").onclick = toggleMute;
      $("hangup").onclick = hangup;
      $("send").onclick = () => {
        const t = input.value.trim();
        if (!t) return;
        sendText(t);
        input.value = "";
      };
      input.addEventListener("keydown", (e) => { if (e.key === "Enter") $("send").click(); });

      setControls("idle");
      if (store.k) toast("key loaded");
    </script>
  </body>
</html>
